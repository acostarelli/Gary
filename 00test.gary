LITERAL:
jmp _skip#
_literal#: dw ###
_skip#
push _literal#

PIPE:
(find next word)
call word

("Yay!" | print)
***
    jmp _skip1
    _literal2: dw "Yay!"
    skip1:
    push _literal2

    call print
***

mynumber @ 4
//4 | mynumber
4 @ mynumber
(4 mynumber | @)
***
    LITERAL SEEN:
    jmp _skip1
    _literal2: dw 4
    _skip1:
    push _literal2

    WORD SEEN (DO NOT DO IF ALREADY SEEN IN THIS SCOPE)
    jmp _skip3
    mynumber: dw 0
    _skip3:
    push mynumber

    PIPE SIGN SEEN: CALL NEXT CHARACTER

    call __gary_assignment

    jmp _skip3
    mynumber: db 0
    _skip3:

    mov dx, [_literal2]
    mov [mynumber], dx
***

"What" | mystring

add func{
    :num1
    :num2

    (num1 2 | +) | num1

    ((num1 num2 | +) return | @)
}
***
add:
    jmp _skip1
    _add_ip: dw 0
    _add_num1: dw 0 
    _add_num2: dw 0
    _add_return: dw 0
    _skip1:

    pop _add_ip
    pop _add_num2
    pop _add_num1

    push _add_num1
    push 2
    call _gary_addition

    

    push [_add_ip]
    ret


***

example @ {
    foo @ true

    loop{
        foo @ false
    }
}

((mynumber 3 | add) | print)
