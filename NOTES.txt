The point of this compiler is to turn the higher-level 
language, Gary, into the lower level language, x86
assembly code. The point of this is so that the Gary
user may use high level structures and complex code
without using assembly. Capice? A compiler to assembly
is a compiler nonetheless so stop worrying about it.

Yes, it might resemble other languages. Who cares.
This is your language.

Features of the language:
- No type definition
- Runs in DOS
- Functional

Some patterns for compilation:
- All names are going to be labels. Knowing what TYPE the name is depends on how
the name is handled when it is seen.
    - A name followed by () means that the label should be call'd.
    - A label standing on its own means that it points to data
        - If the data is a string, code must be inserted so that the string is
          treated like a literal.
        - If the code is a number or anything else, then the label can be
          [dereferenced] and inserted into whatever operation is happening.
- Literals will be clearly defined.
    - A number literal is going to start with a number
    - A string literal is going to start with "
    - A boolean will be either True or False
    - A subroutine will be defined by { }

Considerations:
- Maybe setup a "dibs" system. For example, if the code encounters a name token
  followed by a ( token, then you know it's a call expression. At that point, 
  "dibs" can be called on the next tokens until the final closing parenthesis.
  This prevents having to backtrack or do multiple passes.
    - Hmm. This sounds like a stack.
